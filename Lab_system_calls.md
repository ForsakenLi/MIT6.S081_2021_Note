# Lab: system calls

本实验要求实现两个系统调用，`trace`和`sysinfo`。

## trace

### target

用于跟踪某个用户态程序系统调用的步骤, 需要我们根据一个mask编号，每个内核中的系统调用都对应一个系统调用编号，所有的mask值为1的位对应的系统调用就是需要打印的位，同时还需要打印出该系统调用对应的进程pid以及该系统调用的返回值，如下所示：

```
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
```

此外，如父进程被fork时，子进程的trace需要按照同样的mask规则被打印。

### my solution

我们需要在进程PCB(struct proc)中增加一个mask变量，同时进程被fork时子进程会继承父进程的mask值，该进程在执行系统调用时均会首先进入void syscall()函数，该函数会根据规则从trapframe页中抽取系统调用的编号(a7寄存器)并调用该系统调用的内核态函数，并收集系统调用函数的返回值放入trapframe的a0(之后在返回用户态时被载入对应的a0寄存器); 我们需要做的主要工作就是在`syscall()`中print出PID、系统调用名和返回值。

## sysinfo

### target

实现一个系统调用用于返回当前内核中空闲的物理内存大小和使用中的进程数(非处于UNUSED状态)，需要能够将结果以一个结构体的形式返回到用户态地址空间的指定位置。

### my solution

对于空闲的物理内存大小，我们需要找到内核中存储空闲物理链表的结构；对于进程数统计，我们需要找到存储所有进程PCB的数组(上限为NPROC); 最关键的部分是需要将内核态的结构体拷贝到用户态的地址空间，我们会需要使用用户态进程的PCB，其中保存着用户虚拟地址空间到内存物理地址空间的映射关系表，也就是我们常说的PTE, 通过PTE我们才能将用户指定的希望返回结果的用户态虚拟地址转化为内存中真正的物理地址，我们需要在内核态来将这个结构体存储到这个地址中，这样在返回用户态后用户才能在指定的地址位置解析到该sysinfo结构体。

## enlightenment

通过这次实验，我们可以深入地理解系统调用的运行流程，用户态中的所有系统调用(如write, read等)最终会对ECALL方法发起调用，这是一个保存在内核地址空间名为`蹦床页`(在虚拟地址空间的顶部)的方法，ECALL方法会将系统调用的参数存储在位于蹦床页后方的trapframe地址区域(同样位于内核地址空间)，如下所示:

![img](img/p3.png)

此后ECALL方法还会保存我们的用户态寄存器等一系列操作，此后才会将PC寄存器转移到内核进程(也就是进入上面讨论过的syscall方法)。

对于软件工程师的我们，我们最需要理解的内容是:

1. 在陷入到系统调用时如write，是会发生一次无法避免的数据拷贝的，如write在陷入时就会将要写入到特定文件描述符的内容拷贝到trapframe，所以使用mmap就可以避免这样一次陷入到内核态的而需要地拷贝。

2. 在返回到用户态时，简单的系统调用返回值会同样被拷贝到trapframe的寄存器存储区域，在此后返回到用户态时会被映射到寄存器中；而复杂的结构体需要通过用户指定的地址来返回，所以我们也需要将需要返回的数据拷贝到用户态的虚拟地址对应的物理地址中，这里同样需要发生一次拷贝。

3. 操作系统这样设计的目的是为了保证用户态进程和内核态进程的隔离性，trapframe相当于用户态和内核态传递信息的中间介质，而这一过程的逻辑则由蹦床页中的汇编函数所控制；此外内核态还可以使用PTE，通过找到用户态虚拟地址到物理地址的映射，来完成复杂数据的传递。