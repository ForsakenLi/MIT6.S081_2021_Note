# Lab: page tables

## Speed up system calls

### target

本实验要求实现对系统调用的加速，我们知道操作系统可以将同一块物理内存映射到不同的process地址空间(fork/蹦床页等都基于此方式实现)，在这个实验中我们需要通过这种方式来避免数据从用户态到内核态的拷贝，即直接通过将一块内存映射到内核进程和用户进程来实现高效的信息交换。

### my solution

首先在进程PCB中增加一个指向数据交换使用的usyscall结构体的指针，根据lab提示我们可以关注到`allocproc()`方法，该方法会在进程初始化时为进程完成虚拟地址空间的映射(其实只是完成了最基本的蹦床页和trapframe两个用于内核用户态交换的映射，trapframe会分配真正的物理内存而蹦床页则仅仅是映射到同样的物理内存区域，因为所有的进程蹦床页都是相同的)；我们需要做的就是在`allocproc()`方法中模仿trapframe的方式，分配一块物理内存(使用`kalloc()`方法分配一块物理内存，从空闲链表中获取)，然后将PCB的usyscall地址设置为该物理内存的首地址，并进程虚拟地址空间(`mappages()`方法)映射到这块分配的物理内存中。在进程被释放时需要归还被分配的地址空间。

需要注意的一点是，每个PTE表项都包含这一系列标志位, 其指定着一个页具有何种访问权限和特征：

```
PTE_V指示PTE是否存在：如果它没有被设置，对页面的引用会导致异常（即不允许）。PTE_R控制是否允许指令读取到页面。PTE_W控制是否允许指令写入到页面。PTE_X控制CPU是否可以将页面内容解释为指令并执行它们。PTE_U控制用户模式下的指令是否被允许访问页面；如果没有设置PTE_U，PTE只能在管理模式下使用。
```

在这里我们需要将这个数据交换的页面设置为一个PTE_R ｜ PTE_U。这个标记位存在的作用还使我联想到fork采用的COW技术，在一个fork出的子进程(父进程也是一样的)需要修改自己的页表时，原先我们可以将这个页表设置为只读，因此在它修改时会产生一个异常陷入，这个时候操作系统才会为其分配真正的物理内存(其实只是需要写的这一部分，其余部分继续和父进程共享只读)，不得不感叹操作系统设计的巧妙之处。